#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "graph.h"
#include "time_calc.h"


// Function to create an adjacency list from specified edges
struct Graph* createGraph(struct Edge edges[], int n)
{
    unsigned i;

    // allocate memory for the graph data structure
    struct Graph* graph = (struct Graph*)malloc(sizeof(struct Graph));

    // initialize head pointer for all vertices
    for (i = 0; i < N; i++) {
        graph->head[i] = NULL;
    }

    // add edges to the directed graph one by one
    for (i = 0; i < n; i++)
    {
        // get the source and destination vertex
        int src = edges[i].src;
        int dest = edges[i].dest;
        int weight = edges[i].weight;

        // allocate new node of adjacency list from `src` to `dest`
        struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
        newNode->dest = dest;
        newNode->weight = weight;

        // point new node to current head
        newNode->next = graph->head[src];

        // point head pointer to a new node
        graph->head[src] = newNode;

        // allocate new node of adjacency list from `dest` to `src`
        newNode = (struct Node*)malloc(sizeof(struct Node));
        newNode->dest = src;
        newNode->weight = weight;

        // point new node to current head
        newNode->next = graph->head[dest];

        // change head pointer to point to the new node
        graph->head[dest] = newNode;
    }

    return graph;
}
// Function to print adjacency list representation of a graph
void printGraph(struct Graph* graph)
{
    int i;
    for (i = 0; i < N; i++)
    {
        // print the current vertex and all its neighbors
        struct Node* ptr = graph->head[i];
        while (ptr != NULL)
        {
            printf("%d -> %d (%d)\t", i, ptr->dest, ptr->weight);
            ptr = ptr->next;
        }

        printf("\n");
    }
}

// Weighted Directed Graph Implementation in C


/*
int main(void)
{
    // input array containing edges of the graph (as per above diagram)
    // `(x, y, w)` tuple in the array represents an edge from `x` to `y`
    // having weight `w`
    struct Edge edges[] =
            {
                    { 4, 1, 6 }, { 1, 2, 7 }, { 2, 0, 5 }, { 2, 1, 4 },
                    { 3, 2, 10 }, { 4, 5, 1 }, { 5, 4, 3 }
            };

    // calculate the number of edges
    int n = sizeof(edges)/sizeof(edges[0]);

    // construct a graph from the given edges
    struct Graph *graph = createGraph(edges, n);

    // print adjacency list representation of a graph
    printGraph(graph);

    return 0;
}
 */

// Function that constructs the edges for the graph
struct Edge* build_edges(station_list_node* list, route* r, int route_count, train* t, int train_count){
    struct Edge* edges = malloc(sizeof(struct Edge) * route_count);
    char* allowed_trains;

    for (int i = 0; i < route_count; ++i) {
        edges[i].src = search_station_list(list, r[i].station_start);
        edges[i].dest = search_station_list(list, r[i].station_end);
        edges[i].weight = weight_calc(r[i], *t);
        allowed_trains = compatible_trains(t, r[i], train_count);
        strcpy(edges[i].trains , allowed_trains);
        free(allowed_trains);
    }
    return edges;
}

//helper function for dijkstra_recursive to check if an integer representing a node in the graph is in an array which represents the steps already taken
int visited_position(const int target, const int* positions){
    for (int i = 0; i < N; ++i) {
        if(positions[i] == target){
            return 1;                //returns true if the target integer is somewhere in the positions-array
        }
    }
    return 0;   //if the for-loop finishes, we know the target is not in the positions-array and return false
}

// Recursive function that searches the adjacency list generated by createGraph until it the target node matches the node being searched and returns the smallest weight needed to get there
int dijkstra_recursive(struct Graph* graph, int search_pos, int target, int total_weight, int recursion_nr, int* path){
    if (visited_position(search_pos, path)) {//detect if the algorithm tries to go back, meaning it has hit a dead end
        printf("\nDEAD END AT %d\n", search_pos);
        return -(total_weight + 1);
    } else {
        path[recursion_nr] = search_pos;                   //log current position in the path array where the index corresponds to the step number

        if(search_pos == target) {                         //check if we have reached the target and return 0 if we have, stopping the recursion
            printf("\nFOUND %d\n", search_pos);
            return 0;
        } else {
            printf("\nTRIED %d\n", search_pos);     //call the function on all destinations reachable from search_pos

            struct Node* ptr = graph->head[search_pos];
            int weight = -1;
            int temp;
            while (ptr != NULL){
                temp = dijkstra_recursive(graph, ptr->dest, target, total_weight, recursion_nr + 1, path);

                if(temp != -1){                            //check if we have found an existing route with a smaller weight and replace the weight if we have
                    temp = graph->head[search_pos]->weight + temp;
                    if(temp < weight || weight == -1){
                        weight = temp;
                    }
                }
                ptr = ptr->next;                           //get ready to go to the next destination reachable from search_pos
            }
            return weight;
        }
    }
}

//graph->head[search_pos]->weight + dijkstra_recursive(graph, graph->head[search_pos]->dest, target, total_weight, search_pos);
//code scrap above searches the first available destination

// Helper function for dijkstra_recursive that calls it with the weight-variable set as it should be
int dijkstra(struct Graph* graph, int start_node, int end_node)
{
    int path[N];                    //create an array to hold the path the pathfinding-function takes
    for (int i = 0; i < N; ++i) {
        path[i] = -1;
    }
    return dijkstra_recursive(graph, start_node, end_node, 0, 0, path);
}



